# DirectX12 엔진 개발 - 2026-01-17

## 목차
- [WndProc 콜백 함수 최적화](#q1-wndproc-콜백-함수-최적화)

---

## Q1: WndProc 콜백 함수 최적화

**질문:**
Engine.cpp에서 Callback 함수 최적화 시킬 방법이 있을지

**답변:**

### 1. 메시지 루프 최적화 (가장 중요)

현재 `GetMessage`는 블로킹 함수로, 메시지가 없으면 대기합니다. 게임 엔진에서는 `PeekMessage`를 사용해야 합니다.

```cpp
// 현재 (블로킹 - 게임에 부적합)
while (GetMessage(&msg, nullptr, 0, 0)) { ... }

// 권장 (논블로킹 - 게임 루프)
while (true)
{
    if (PeekMessage(&msg, nullptr, 0, 0, PM_REMOVE))
    {
        if (msg.message == WM_QUIT) break;
        TranslateMessage(&msg);
        DispatchMessage(&msg);
    }
    else
    {
        // 게임 로직 실행 (Update, Render)
    }
}
```

### 2. 메시지 핸들러 테이블 (함수 포인터)

switch-case가 많아지면 점프 테이블 또는 해시맵 기반 디스패치가 더 효율적입니다.

```cpp
// 메시지 핸들러 타입 정의
using MsgHandler = LRESULT(*)(HWND, WPARAM, LPARAM);
std::unordered_map<UINT, MsgHandler> g_MsgHandlers;

// 초기화 시 등록
g_MsgHandlers[WM_PAINT]   = OnPaint;
g_MsgHandlers[WM_DESTROY] = OnDestroy;
g_MsgHandlers[WM_KEYDOWN] = OnKeyDown;

// WndProc에서 사용
LRESULT CALLBACK WndProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    auto it = g_MsgHandlers.find(msg);
    if (it != g_MsgHandlers.end())
        return it->second(hWnd, wParam, lParam);
    return DefWindowProc(hWnd, msg, wParam, lParam);
}
```

### 3. WM_PAINT 처리 최적화

DX12 엔진에서는 GDI 기반 `BeginPaint`/`EndPaint`가 불필요합니다.

```cpp
case WM_PAINT:
    // DX12에서는 스왑체인이 렌더링 담당
    // 단순히 유효화만 처리
    ValidateRect(hWnd, nullptr);
    return 0;
```

### 4. 입력 처리 분리

입력은 WndProc에서 버퍼링하고, 게임 루프에서 처리하는 것이 좋습니다.

```cpp
// 입력 상태 버퍼
class InputBuffer {
    bool keys[256] = {};
public:
    void OnKeyDown(WPARAM key) { keys[key] = true; }
    void OnKeyUp(WPARAM key)   { keys[key] = false; }
    bool IsKeyDown(int key) const { return keys[key]; }
};

// WndProc에서는 버퍼에만 기록
case WM_KEYDOWN: g_Input.OnKeyDown(wParam); return 0;
case WM_KEYUP:   g_Input.OnKeyUp(wParam);   return 0;
```

### 5. Raw Input 사용 (고급)

고정밀 마우스 입력이 필요하면 `WM_INPUT` + Raw Input API 사용:

```cpp
// 등록
RAWINPUTDEVICE rid = {};
rid.usUsagePage = 0x01;  // Generic Desktop
rid.usUsage = 0x02;      // Mouse
rid.dwFlags = 0;
rid.hwndTarget = hWnd;
RegisterRawInputDevices(&rid, 1, sizeof(rid));
```

### 성능 영향도 정리

| 최적화 항목 | 영향도 | 비고 |
|------------|--------|------|
| GetMessage → PeekMessage | **매우 높음** | 필수 변경 |
| WM_PAINT 간소화 | 중간 | DX12 사용 시 필수 |
| 입력 버퍼링 | 중간 | 프레임 일관성 향상 |
| 메시지 핸들러 테이블 | 낮음 | 메시지 종류 많을 때 유리 |
| Raw Input | 낮음 | FPS 게임 등 정밀 입력 필요 시 |

**결론:** 가장 먼저 PeekMessage 기반 게임 루프로 변경하는 것이 핵심입니다. 현재 구조로는 메시지가 없을 때 렌더링이 멈추게 됩니다.

---
