# DirectX12 엔진 개발 - 2026-01-16

## 목차
- [D3D11과 D3D12 함께 사용하기 및 Include 순서](#q1-d3d11과-d3d12-함께-사용하기-및-include-순서)
- [Rider IDE에서 미리 컴파일된 헤더(PCH) 설정](#q2-rider-ide에서-미리-컴파일된-헤더pch-설정)
- [와일드카드 Include와 폴더 구조 설계](#q3-와일드카드-include와-폴더-구조-설계)
- [언리얼 엔진의 모듈 시스템과 자동 파일 생성](#q4-언리얼-엔진의-모듈-시스템과-자동-파일-생성)
- [빌드 스크립트 언어 선택: C# vs Python](#q5-빌드-스크립트-언어-선택-c-vs-python)
- [빌드 시 Python 스크립트 자동 실행](#q6-빌드-시-python-스크립트-자동-실행)
- [#include 형식 변경: 상대경로에서 꺾쇠괄호로](#q7-include-형식-변경-상대경로에서-꺾쇠괄호로)

---

## Q1: D3D11과 D3D12 함께 사용하기 및 Include 순서

**질문:**
d3d11과 d3d12를 모두 이용하는 것이 가능한지, 그리고 가능하다면 include 순서를 어떻게 해야 하는지

**답변:**

### D3D11과 D3D12 함께 사용 가능 여부

**가능합니다.** Microsoft는 공식적으로 두 API의 상호 운용을 지원합니다.

#### 대표적인 사용 사례

**1. D3D11on12**
- D3D12 디바이스 위에서 D3D11 API를 사용하는 호환 레이어
- 기존 D3D11 코드를 D3D12 환경에서 실행 가능
- 점진적 마이그레이션에 유용

**2. 리소스 공유**
- `ID3D12Device::CreateSharedHandle`로 D3D12 리소스를 D3D11에서 사용
- DXGI의 공유 핸들 메커니즘 활용
- 두 API 간 텍스처, 버퍼 공유 가능

**3. 점진적 마이그레이션**
- 렌더링 파이프라인 일부만 D3D12로 전환
- UI나 후처리는 D3D11 유지
- 리스크를 줄이며 단계적 업그레이드

---

### Include 순서 권장

```cpp
// 1. DXGI (공통 인프라) - 가장 먼저
#include <dxgi1_6.h>
#pragma comment(lib, "dxgi.lib")

// 2. D3D 공통 헤더
#include <d3dcommon.h>

// 3. D3D12 (저수준 API) - D3D11보다 먼저
#include <d3d12.h>
#pragma comment(lib, "d3d12.lib")
#include <d3d12shader.h>

// 4. D3D11 (고수준 API)
#include <d3d11.h>
#pragma comment(lib, "d3d11.lib")

// 5. D3D11on12 (상호 운용 필요 시)
#include <d3d11on12.h>

// 6. 셰이더 컴파일러
#include <d3dcompiler.h>
#pragma comment(lib, "d3dcompiler.lib")
```

---

### 순서 결정의 원칙

#### 1. DXGI를 가장 먼저
- DXGI는 D3D11과 D3D12 모두의 기반 인프라
- 어댑터, 스왑체인 등 공통 타입 정의
- 두 API 모두 DXGI 타입에 의존

#### 2. D3D12를 D3D11보다 먼저
- D3D12가 더 저수준 API
- D3D11on12 사용 시 D3D12 타입이 먼저 정의되어야 함
- 의존성 방향: D3D11 → D3D12 → DXGI

#### 3. 셰이더 컴파일러는 마지막
- 런타임 셰이더 컴파일에 사용
- D3D 디바이스 타입과 독립적

---

### D3D11on12 사용 예시

```cpp
// D3D12 디바이스 생성 후
ID3D12Device* d3d12Device;
ID3D12CommandQueue* commandQueue;

// D3D11on12 디바이스 생성
ID3D11Device* d3d11Device;
ID3D11DeviceContext* d3d11Context;
D3D11On12CreateDevice(
    d3d12Device,
    D3D11_CREATE_DEVICE_BGRA_SUPPORT,
    nullptr, 0,
    reinterpret_cast<IUnknown**>(&commandQueue), 1,
    0,
    &d3d11Device,
    &d3d11Context,
    nullptr
);

// D3D11 API로 렌더링 가능
// 내부적으로 D3D12 커맨드로 변환됨
```

---

### 주의사항

1. **성능 오버헤드**: D3D11on12는 변환 비용이 있음
2. **동기화 관리**: 두 API 간 리소스 상태 동기화 필요
3. **디버깅 복잡도**: 두 API의 디버그 레이어를 모두 확인해야 함
4. **최종 목표 설정**: 완전한 D3D12 마이그레이션인지, 혼용 유지인지 결정

---

## Q2: Rider IDE에서 미리 컴파일된 헤더(PCH) 설정

**질문:**
Visual Studio에서 하는 PCH 설정을 Rider IDE에서 적용시키는 방법

**답변:**

Rider는 Visual Studio 프로젝트 파일(`.vcxproj`)을 직접 사용하므로 두 가지 방법이 있습니다.

### 방법 1: vcxproj 파일 직접 수정 (권장)

프로젝트의 `.vcxproj` 파일에 다음을 추가합니다:

```xml
<!-- 프로젝트 전체에 PCH 사용 설정 -->
<ItemDefinitionGroup>
  <ClCompile>
    <PrecompiledHeader>Use</PrecompiledHeader>
    <PrecompiledHeaderFile>framework.h</PrecompiledHeaderFile>
  </ClCompile>
</ItemDefinitionGroup>

<!-- framework.cpp만 "Create"로 설정 -->
<ItemGroup>
  <ClCompile Include="framework.cpp">
    <PrecompiledHeader>Create</PrecompiledHeader>
  </ClCompile>
</ItemGroup>
```

### 방법 2: Rider UI에서 설정

1. **Solution Explorer**에서 프로젝트 우클릭 → **Properties**
2. **C/C++** → **Precompiled Headers**
3. Visual Studio와 동일하게 설정

단, Rider 버전에 따라 UI가 제한적일 수 있어 **방법 1이 더 확실**합니다.

---

### framework.cpp 생성

```cpp
#include "framework.h"
```

이 한 줄만 있으면 됩니다. PCH 생성 전용 파일입니다.

---

### PCH 사용 시 주의사항

1. **모든 cpp 파일**의 첫 번째 include는 `framework.h`여야 함
2. PCH에 자주 변경되는 헤더를 넣으면 재컴파일 비용 증가
3. 안정적인 헤더(STL, Windows, DirectX)만 PCH에 포함 권장

---

## Q3: 와일드카드 Include와 폴더 구조 설계

**질문:**
파일 구조를 Public/{Declare}.h와 Private/{Definition}.cpp로 나누고, Public의 헤더파일들을 `#include <Public/*>` 같이 한번에 포함시킬 수 있는지

**답변:**

### 와일드카드 Include

**불가능합니다.** C/C++ 표준은 와일드카드 include를 지원하지 않습니다.

```cpp
#include <Public/*>      // ❌ 지원 안 됨
#include "Public/*.h"    // ❌ 지원 안 됨
```

---

### 대안 1: 올헤더(All-Header) 패턴 (권장)

가장 실용적이고 널리 사용되는 방법입니다.

```
Engine/
├── Public/
│   ├── Public.h          ← 이 파일이 모든 헤더를 include
│   ├── Actor.h
│   ├── Component.h
│   └── Renderer.h
├── Private/
│   ├── Actor.cpp
│   ├── Component.cpp
│   └── Renderer.cpp
└── framework.h
```

**Public/Public.h**:
```cpp
#pragma once

// Public 폴더의 모든 헤더를 여기서 관리
#include "Actor.h"
#include "Component.h"
#include "Renderer.h"
// 새 헤더 추가 시 여기에 한 줄 추가
```

**framework.h**:
```cpp
#pragma once

// ... Windows, STL, DirectX headers ...

// 프로젝트 헤더 - 한 줄로 전체 포함
#include "Public/Public.h"
```

---

### 대안 2: 빌드 스크립트 자동 생성

빌드 전에 스크립트로 `Public.h`를 자동 생성합니다.

**Python 예시 (generate_public.py)**:
```python
import glob
import os

headers = glob.glob("Public/*.h")
headers = [h for h in headers if not h.endswith("Public.h")]

with open("Public/Public.h", "w") as f:
    f.write("#pragma once\n\n")
    for h in sorted(headers):
        name = os.path.basename(h)
        f.write(f'#include "{name}"\n')
```

**CMake 예시**:
```cmake
file(GLOB PUBLIC_HEADERS "Public/*.h")
# 빌드 시 자동으로 Public.h 생성하는 커스텀 커맨드 추가
```

---

### 대안 3: Unity Build (참고용)

모든 cpp를 하나의 파일로 합쳐 컴파일하는 방식입니다.

```cpp
// Unity.cpp
#include "Private/Actor.cpp"
#include "Private/Component.cpp"
#include "Private/Renderer.cpp"
```

- 장점: 컴파일 속도 향상, 링커 최적화
- 단점: 이름 충돌 위험, 증분 빌드 불가

대규모 프로젝트에서는 사용하지만 복잡도가 높아 **비권장**입니다.

---

### 권장 구조

```
Engine/
├── Public/
│   ├── Public.h              ← 모든 public 헤더 include
│   ├── Core/
│   │   ├── Core.h            ← Core 모듈 헤더
│   │   ├── Object.h
│   │   └── Actor.h
│   └── Rendering/
│       ├── Rendering.h       ← Rendering 모듈 헤더
│       ├── Renderer.h
│       └── Material.h
├── Private/
│   ├── Core/
│   │   ├── Object.cpp
│   │   └── Actor.cpp
│   └── Rendering/
│       ├── Renderer.cpp
│       └── Material.cpp
└── framework.h
```

모듈별로 올헤더를 만들면 관리가 더 쉬워집니다.

---

### 결론

| 방법 | 장점 | 단점 |
|------|------|------|
| 올헤더 패턴 | 간단, 명시적 | 수동 관리 필요 |
| 빌드 스크립트 | 자동화 | 빌드 시스템 의존 |
| Unity Build | 빌드 속도 | 복잡도 높음 |

**올헤더 패턴**이 가장 현실적입니다. 새 헤더 추가 시 `Public.h`에 한 줄만 추가하면 됩니다.

---

## Q4: 언리얼 엔진의 모듈 시스템과 자동 파일 생성

**질문:**
언리얼 엔진에서는 어떤 방식으로 해결했는지? Public 폴더에 헤더를 만들고 "정의부 만들기"하면 Private 폴더에 같은 경로로 자동 생성되는 방식

**답변:**

### 언리얼 엔진의 빌드 시스템

언리얼은 MSBuild나 CMake가 아닌 **자체 빌드 시스템**을 사용합니다.

#### 1. Unreal Build Tool (UBT)

```csharp
// Source/MyGame/MyModule.Build.cs
public class MyModule : ModuleRules
{
    public MyModule(ReadOnlyTargetRules Target) : base(Target)
    {
        PCHUsage = PCHUsageMode.UseExplicitOrSharedPCHs;

        // Public, Private 폴더를 자동으로 인식
        PublicIncludePaths.AddRange(new string[] { "Public" });
        PrivateIncludePaths.AddRange(new string[] { "Private" });

        // 모듈 의존성
        PublicDependencyModuleNames.AddRange(new string[] {
            "Core",
            "CoreUObject",
            "Engine"
        });
    }
}
```

UBT가 `Public/`, `Private/` 폴더 구조를 **규약(Convention)**으로 인식하고 자동 처리합니다.

#### 2. Unreal Header Tool (UHT)

```cpp
// Public/MyActor.h
#pragma once

#include "CoreMinimal.h"
#include "GameFramework/Actor.h"
#include "MyActor.generated.h"  // UHT가 자동 생성

UCLASS()
class MYGAME_API AMyActor : public AActor
{
    GENERATED_BODY()  // UHT가 파싱하여 리플렉션 코드 생성

public:
    UPROPERTY(EditAnywhere)
    float Health;

    UFUNCTION(BlueprintCallable)
    void TakeDamage(float Amount);
};
```

UHT가 `UCLASS`, `UPROPERTY`, `UFUNCTION` 매크로를 파싱하여 `*.generated.h` 파일을 자동 생성합니다.

---

### 자동 파일 생성의 비밀: IDE 플러그인

Public에서 "정의부 만들기"하면 Private에 자동 생성되는 것은 **IDE 플러그인** 기능입니다.

#### Rider의 경우

- **RiderLink 플러그인**: 언리얼 에디터와 Rider 연동
- **Unreal Engine Support**: 언리얼 컨벤션 인식

Rider가 언리얼의 폴더 규약을 알고 있어서:
1. `Public/Core/MyClass.h` 생성
2. "정의부 만들기" 실행
3. 자동으로 `Private/Core/MyClass.cpp` 생성 (경로 미러링)

#### Visual Studio의 경우

- **UnrealVS Extension**: Epic Games 제공 확장
- 클래스 마법사로 파일 쌍 자동 생성

---

### 일반 DX12 프로젝트에서 유사하게 구현하기

#### 방법 1: Rider Live Templates / File Templates

**Settings → Editor → File and Code Templates**

**Header Template** (`Public/${NAME}.h`):
```cpp
#pragma once

class ${NAME}
{
public:
    ${NAME}();
    ~${NAME}();

private:
};
```

**Source Template** (`Private/${NAME}.cpp`):
```cpp
#include "framework.h"
#include "${NAME}.h"

${NAME}::${NAME}()
{
}

${NAME}::~${NAME}()
{
}
```

#### 방법 2: Python 스크립트

```python
# create_class.py
import sys
import os

def create_class(name, subdir=""):
    public_dir = os.path.join("Public", subdir)
    private_dir = os.path.join("Private", subdir)

    os.makedirs(public_dir, exist_ok=True)
    os.makedirs(private_dir, exist_ok=True)

    # Header
    header_path = os.path.join(public_dir, f"{name}.h")
    with open(header_path, "w") as f:
        f.write(f"""#pragma once

class {name}
{{
public:
    {name}();
    ~{name}();
}};
""")

    # Source
    source_path = os.path.join(private_dir, f"{name}.cpp")
    with open(source_path, "w") as f:
        f.write(f"""#include "framework.h"
#include "{name}.h"

{name}::{name}()
{{
}}

{name}::~{name}()
{{
}}
""")

    print(f"Created: {header_path}")
    print(f"Created: {source_path}")

if __name__ == "__main__":
    name = sys.argv[1]
    subdir = sys.argv[2] if len(sys.argv) > 2 else ""
    create_class(name, subdir)
```

**사용법**:
```bash
python create_class.py MyActor Core
# 결과:
# Public/Core/MyActor.h
# Private/Core/MyActor.cpp
```

#### 방법 3: Rider 외부 도구 등록

**Settings → Tools → External Tools**에 스크립트 등록:
- Program: `python`
- Arguments: `create_class.py $FileNameWithoutExtension$ $FileParentDir$`

우클릭 메뉴에서 바로 실행 가능하게 설정합니다.

---

### 언리얼 vs 일반 프로젝트 비교

| 기능 | 언리얼 엔진 | 일반 C++ 프로젝트 |
|------|------------|------------------|
| 빌드 시스템 | UBT (자체) | MSBuild/CMake |
| 폴더 자동 인식 | ✅ 내장 | ❌ 수동 설정 필요 |
| 코드 자동 생성 | UHT | ❌ 없음 |
| IDE 파일 생성 | 플러그인 지원 | 템플릿 직접 설정 |
| 모듈 시스템 | .Build.cs | 없음 (수동 관리) |

---

### 결론

언리얼의 편의 기능은 **자체 빌드 도구(UBT/UHT) + IDE 플러그인**의 조합입니다.

일반 프로젝트에서 유사한 경험을 원한다면:
1. **Rider File Templates** 설정 (가장 간단)
2. **Python 스크립트** + 외부 도구 등록
3. **CMake + 커스텀 타겟**으로 자동화

완전히 동일한 수준은 어렵지만, 템플릿과 스크립트로 상당 부분 자동화할 수 있습니다.

---

## Q5: 빌드 스크립트 언어 선택: C# vs Python

**질문:**
C# 코드를 프로젝트에 포함시킬 수 있는지? C#과 Python으로 구현부 생성 및 Public Include 스크립트를 만들 때 속도 차이가 있는지?

**답변:**

### C#을 프로젝트에 포함시킬 수 있는가?

#### 용도별 가능 여부

| 용도 | 가능 여부 | 복잡도 | 방법 |
|------|----------|--------|------|
| 빌드/도구 스크립트 | ✅ 가능 | 쉬움 | .NET CLI로 실행 |
| 에디터/툴 개발 | ✅ 가능 | 쉬움 | 별도 exe로 빌드 |
| 런타임 코드 혼합 | ⚠️ 가능 | 복잡 | C++/CLI, COM Interop |

#### 빌드 도구로 사용 (권장)

```
프로젝트 구조:
Engine/
├── Source/           ← C++ 코드
├── Tools/            ← C# 빌드 도구
│   ├── CreateClass/
│   │   ├── CreateClass.csproj
│   │   └── Program.cs
│   └── GeneratePublicHeader/
│       ├── GeneratePublicHeader.csproj
│       └── Program.cs
└── Engine.sln
```

C#으로 만든 도구는 `dotnet run` 또는 빌드된 exe로 실행합니다.

#### 런타임 혼합 (비권장)

C++와 C#을 런타임에 혼합하려면:
- **C++/CLI**: Managed/Unmanaged 코드 브릿지 (복잡)
- **COM Interop**: COM 인터페이스로 통신 (복잡)
- **P/Invoke**: C++ DLL을 C#에서 호출 (단방향)

게임 엔진에서는 보통 **빌드 도구로만** C#을 사용합니다.

---

### 속도 비교: C# vs Python

#### 파일 생성 스크립트 벤치마크 (대략적 수치)

```
┌──────────────────┬─────────────┬─────────────┬─────────────┐
│ 언어              │ Cold Start  │ 파일 10개    │ 파일 100개   │
├──────────────────┼─────────────┼─────────────┼─────────────┤
│ Python 3.x       │ ~100ms      │ ~120ms      │ ~200ms      │
│ C# (dotnet run)  │ ~500ms      │ ~520ms      │ ~550ms      │
│ C# (빌드된 exe)   │ ~50ms       │ ~60ms       │ ~100ms      │
│ C# (Native AOT)  │ ~20ms       │ ~30ms       │ ~80ms       │
└──────────────────┴─────────────┴─────────────┴─────────────┘
```

#### 분석

**Cold Start (첫 실행)**:
- Python: 인터프리터 로드 ~100ms
- C# (dotnet run): JIT 컴파일 포함 ~500ms
- C# (exe): CLR 로드 ~50ms
- C# (Native AOT): 네이티브 바이너리 ~20ms

**실제 작업 (파일 I/O)**:
- 둘 다 파일 I/O가 병목
- 언어 자체 속도는 무의미한 수준
- SSD 기준 파일 하나 쓰기 ~1ms

#### 결론: 체감 차이 없음

파일 몇 개 생성하는 스크립트는 **어떤 언어든 1초 미만**에 완료됩니다.

---

### 언어별 장단점 비교

| 항목 | Python | C# |
|------|--------|-----|
| **설치 필요** | Python 런타임 | .NET 런타임 (Windows 기본) |
| **배포** | .py 파일 그대로 | exe로 빌드 가능 |
| **Windows 통합** | 보통 | 우수 (네이티브) |
| **크로스 플랫폼** | 우수 | 가능 (.NET Core) |
| **학습 곡선** | 낮음 | 중간 |
| **IDE 지원** | 보통 | Rider/VS에서 우수 |
| **타입 안정성** | 약함 | 강함 |

---

### 권장 선택 가이드

```
빠른 프로토타입이 필요하다
    └─→ Python

Windows 전용 + 배포 편의성 중요
    └─→ C# (exe로 빌드)

크로스 플랫폼 필요
    └─→ Python

팀 내 C# 경험이 풍부하다
    └─→ C#

언리얼 스타일 빌드 시스템 구축
    └─→ C# (UBT가 C#)
```

---

### C# 스크립트 예시

```csharp
// Tools/CreateClass/Program.cs
using System;
using System.IO;

class Program
{
    static void Main(string[] args)
    {
        if (args.Length < 1)
        {
            Console.WriteLine("Usage: CreateClass <ClassName> [SubDir]");
            return;
        }

        string className = args[0];
        string subDir = args.Length > 1 ? args[1] : "";

        string publicDir = Path.Combine("Public", subDir);
        string privateDir = Path.Combine("Private", subDir);

        Directory.CreateDirectory(publicDir);
        Directory.CreateDirectory(privateDir);

        // Header
        string headerPath = Path.Combine(publicDir, $"{className}.h");
        File.WriteAllText(headerPath, $@"#pragma once

class {className}
{{
public:
    {className}();
    ~{className}();
}};
");

        // Source
        string sourcePath = Path.Combine(privateDir, $"{className}.cpp");
        File.WriteAllText(sourcePath, $@"#include ""framework.h""
#include ""{className}.h""

{className}::{className}()
{{
}}

{className}::~{className}()
{{
}}
");

        Console.WriteLine($"Created: {headerPath}");
        Console.WriteLine($"Created: {sourcePath}");
    }
}
```

**프로젝트 파일** (`CreateClass.csproj`):
```xml
<Project Sdk="Microsoft.NET.Sdk">
  <PropertyGroup>
    <OutputType>Exe</OutputType>
    <TargetFramework>net8.0</TargetFramework>
    <ImplicitUsings>enable</ImplicitUsings>
  </PropertyGroup>
</Project>
```

**실행**:
```bash
# 개발 중
dotnet run --project Tools/CreateClass -- MyActor Core

# 빌드 후
dotnet build Tools/CreateClass -c Release
Tools/CreateClass/bin/Release/net8.0/CreateClass.exe MyActor Core
```

---

### 최종 권장

| 상황 | 권장 |
|------|------|
| 개인 프로젝트 + 빠른 시작 | **Python** |
| 팀 프로젝트 + Windows 전용 | **C#** |
| 언리얼처럼 본격적인 빌드 시스템 | **C#** |

속도는 신경 쓸 필요 없습니다. **팀의 익숙함**과 **유지보수 편의성**으로 선택하세요.

---

## Q6: 빌드 시 Python 스크립트 자동 실행

**질문:**
프로젝트에 Python 파일을 import하고, 빌드 시 import된 코드를 실행시키는 자동화 방법

**답변:**

### 프로젝트 구조

```
Engine/
├── Public/
│   ├── Public.h          ← 빌드 시 자동 생성
│   ├── Actor.h
│   └── Component.h
├── Private/
│   └── ...
├── Tools/
│   ├── generate_public.py    ← 빌드 스크립트
│   └── create_class.py
├── Engine.vcxproj
└── framework.h
```

---

### 방법 1: Pre-Build Event (가장 간단)

**Visual Studio / Rider에서 설정**:
1. 프로젝트 우클릭 → **Properties**
2. **Build Events** → **Pre-Build Event**
3. Command Line에 입력:

```bash
python "$(ProjectDir)Tools\generate_public.py"
```

**또는 vcxproj에 직접 추가**:
```xml
<PropertyGroup>
  <PreBuildEvent>python "$(ProjectDir)Tools\generate_public.py"</PreBuildEvent>
</PropertyGroup>
```

---

### 방법 2: MSBuild Target (권장)

vcxproj 파일에 Custom Target을 추가합니다.

```xml
<!-- Engine.vcxproj -->
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">

  <!-- 기존 내용... -->

  <!-- Python 스크립트를 프로젝트에 포함 (Solution Explorer에 표시) -->
  <ItemGroup>
    <None Include="Tools\generate_public.py" />
    <None Include="Tools\create_class.py" />
  </ItemGroup>

  <!-- 빌드 전 실행 -->
  <Target Name="GeneratePublicHeader" BeforeTargets="ClCompile">
    <Message Text="Generating Public.h..." Importance="high" />
    <Exec Command="python &quot;$(ProjectDir)Tools\generate_public.py&quot; &quot;$(ProjectDir)&quot;" />
  </Target>

</Project>
```

---

### 방법 3: 조건부 실행 (파일 변경 시에만)

헤더 파일이 변경되었을 때만 스크립트를 실행합니다.

```xml
<Target Name="GeneratePublicHeader"
        BeforeTargets="ClCompile"
        Inputs="@(ClInclude)"
        Outputs="$(ProjectDir)Public\Public.h">
  <Message Text="Header files changed, regenerating Public.h..." Importance="high" />
  <Exec Command="python &quot;$(ProjectDir)Tools\generate_public.py&quot; &quot;$(ProjectDir)&quot;" />
</Target>
```

- **Inputs**: 감시할 파일들 (헤더 파일)
- **Outputs**: 생성될 파일
- Input 중 하나라도 Output보다 새로우면 실행

---

### 방법 4: 여러 스크립트 순차 실행

```xml
<Target Name="PreBuildScripts" BeforeTargets="ClCompile">
  <!-- 1. Public.h 생성 -->
  <Exec Command="python &quot;$(ProjectDir)Tools\generate_public.py&quot; &quot;$(ProjectDir)&quot;" />

  <!-- 2. 버전 정보 생성 -->
  <Exec Command="python &quot;$(ProjectDir)Tools\generate_version.py&quot; &quot;$(ProjectDir)&quot;" />

  <!-- 3. 에셋 목록 생성 -->
  <Exec Command="python &quot;$(ProjectDir)Tools\generate_assets.py&quot; &quot;$(ProjectDir)&quot;" />
</Target>
```

---

### generate_public.py 완성본

```python
#!/usr/bin/env python3
# Tools/generate_public.py
"""
빌드 전 Public 폴더의 모든 헤더를 Public.h에 자동 포함
Usage: python generate_public.py [project_dir]
"""

import os
import sys
import glob

def generate_public_header(project_dir):
    public_dir = os.path.join(project_dir, "Public")
    output_path = os.path.join(public_dir, "Public.h")

    if not os.path.exists(public_dir):
        print(f"Warning: Public directory not found: {public_dir}")
        return

    # Public 폴더의 모든 .h 파일 찾기 (재귀)
    pattern = os.path.join(public_dir, "**", "*.h")
    headers = glob.glob(pattern, recursive=True)

    # Public.h 자체는 제외
    headers = [h for h in headers if not h.endswith("Public.h")]

    # 정렬 (일관된 순서)
    headers.sort()

    # Public.h 생성
    with open(output_path, "w", encoding="utf-8") as f:
        f.write("#pragma once\n")
        f.write("\n")
        f.write("// ============================================\n")
        f.write("// Auto-generated by Tools/generate_public.py\n")
        f.write("// Do not edit this file manually!\n")
        f.write("// ============================================\n")
        f.write("\n")

        for header in headers:
            # 상대 경로로 변환
            rel_path = os.path.relpath(header, public_dir)
            rel_path = rel_path.replace("\\", "/")  # Windows 경로 정규화
            f.write(f'#include "{rel_path}"\n')

    print(f"[generate_public.py] Generated: Public.h ({len(headers)} headers)")

def main():
    # 프로젝트 디렉토리 결정
    if len(sys.argv) > 1:
        project_dir = sys.argv[1]
    else:
        # 스크립트 위치 기준으로 상위 디렉토리
        script_dir = os.path.dirname(os.path.abspath(__file__))
        project_dir = os.path.dirname(script_dir)

    generate_public_header(project_dir)

if __name__ == "__main__":
    main()
```

---

### 빌드 출력 예시

```
1>------ Build started: Project: Engine, Configuration: Debug x64 ------
1>Generating Public.h...
1>[generate_public.py] Generated: Public.h (5 headers)
1>framework.cpp
1>Engine.cpp
1>Actor.cpp
1>========== Build: 1 succeeded ==========
```

---

### MSBuild 변수 참조

| 변수 | 설명 | 예시 |
|------|------|------|
| `$(ProjectDir)` | 프로젝트 폴더 | `E:\Project\DX12\Engine\` |
| `$(SolutionDir)` | 솔루션 폴더 | `E:\Project\DX12\` |
| `$(Configuration)` | 빌드 구성 | `Debug` / `Release` |
| `$(Platform)` | 플랫폼 | `x64` / `Win32` |
| `$(OutDir)` | 출력 폴더 | `$(SolutionDir)bin\$(Configuration)\` |

---

### 주의사항

1. **Python 경로**: 시스템 PATH에 Python이 있어야 함
   - 또는 절대 경로 사용: `C:\Python311\python.exe`

2. **인코딩**: 한글 경로 문제 방지를 위해 UTF-8 사용
   ```python
   open(path, "w", encoding="utf-8")
   ```

3. **에러 처리**: 스크립트 실패 시 빌드 중단됨
   ```xml
   <Exec Command="..." IgnoreExitCode="true" />  <!-- 실패해도 계속 -->
   ```

4. **Rider 호환**: vcxproj 수정은 Rider에서도 동일하게 작동

---

### 최종 vcxproj 예시

```xml
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">

  <!-- 기존 PropertyGroup, ItemGroup 등... -->

  <!-- 도구 스크립트 (Solution Explorer에 표시) -->
  <ItemGroup>
    <None Include="Tools\generate_public.py" />
    <None Include="Tools\create_class.py" />
  </ItemGroup>

  <!-- Pre-Build: Public.h 자동 생성 -->
  <Target Name="GeneratePublicHeader" BeforeTargets="ClCompile">
    <Message Text="[Pre-Build] Generating Public.h..." Importance="high" />
    <Exec Command="python &quot;$(ProjectDir)Tools\generate_public.py&quot; &quot;$(ProjectDir)&quot;" />
  </Target>

  <!-- 기존 Import 등... -->

</Project>
```

---

## Q7: #include 형식 변경: 상대경로에서 꺾쇠괄호로

**질문:**
`#include "Main/framework.h"` 대신 `#include <framework>` 형태로 대체가 가능한지?

**답변:**

### 결론: 가능하지만 설정 필요

`#include <framework>` 형태로 대체하는 것은 가능합니다. 다만 몇 가지 설정이 필요합니다.

---

### 두 형식의 차이점

| 형식 | 검색 순서 |
|------|----------|
| `#include "file.h"` | 현재 파일 위치 → 추가 포함 디렉터리 |
| `#include <file>` | 추가 포함 디렉터리만 검색 |

- `"..."`: 현재 파일의 디렉터리를 먼저 검색
- `<...>`: 시스템/프로젝트 포함 디렉터리만 검색

---

### 설정 방법

#### 1. 추가 포함 디렉터리 설정

`framework.h`가 있는 폴더를 프로젝트의 포함 디렉터리에 추가해야 합니다.

**프로젝트 속성 → C/C++ → 일반 → 추가 포함 디렉터리**:
```
$(ProjectDir)Main
```

또는 vcxproj에 직접 추가:
```xml
<ItemDefinitionGroup>
  <ClCompile>
    <AdditionalIncludeDirectories>$(ProjectDir)Main;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
  </ClCompile>
</ItemDefinitionGroup>
```

---

### 권장 방식

**`#include <framework.h>`** 형태가 가장 실용적입니다.
- 추가 포함 디렉터리만 설정하면 됨
- 파일명 변경 불필요
- 외부 라이브러리처럼 깔끔한 표현

---

### 최종 설정 예시

**vcxproj**:
```xml
<ItemDefinitionGroup>
  <ClCompile>
    <AdditionalIncludeDirectories>
      $(ProjectDir)Main;
      $(ProjectDir)Public;
      %(AdditionalIncludeDirectories)
    </AdditionalIncludeDirectories>
  </ClCompile>
</ItemDefinitionGroup>
```

**사용**:
```cpp
// 기존
#include "Main/framework.h"

// 변경 후
#include <framework.h>
```

---

