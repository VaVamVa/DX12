# DirectX12 엔진 개발 - 2025-12-10

## 목차
- [DirectX11 vs DirectX12 차이점 및 장단점](#q1-directx11-vs-directx12-차이점-및-장단점)
- [DXGI 라이브러리 역할과 헤더 버전 구조](#q2-dxgi-라이브러리-역할과-헤더-버전-구조)

---

## Q1: DirectX11 vs DirectX12 차이점 및 장단점

**질문:**
DirectX11 과 DirectX12 의 차이점, 장단점

**답변:**

### 주요 차이점

#### 1. API 추상화 레벨
- **DirectX11**: 고수준 API - 드라이버가 많은 작업을 자동으로 처리
- **DirectX12**: 저수준 API - 개발자가 GPU를 직접 제어

#### 2. 멀티스레딩
- **DirectX11**: 제한적인 멀티스레딩 지원 (Deferred Context)
- **DirectX12**: 네이티브 멀티스레딩 - 여러 스레드에서 동시에 Command List 생성 가능

#### 3. 메모리 관리
- **DirectX11**: 암묵적 메모리 관리 - 드라이버가 자동 처리
- **DirectX12**: 명시적 메모리 관리 - 개발자가 직접 메모리 할당/동기화 관리

#### 4. 상태 관리
- **DirectX11**: 상태 변경이 즉시 적용
- **DirectX12**: Pipeline State Object (PSO)로 상태를 미리 컴파일

#### 5. 동기화
- **DirectX11**: 드라이버가 자동으로 동기화 처리
- **DirectX12**: 개발자가 Fence를 사용해 명시적으로 동기화

---

### DirectX12의 장점

**성능 측면:**
1. **CPU 오버헤드 감소**: API 호출 비용이 낮아 Draw Call 수 증가 가능
2. **병렬 처리**: 멀티코어 CPU 활용도 극대화
3. **메모리 효율**: 명시적 관리로 메모리 사용 최적화
4. **GPU 효율**: Async Compute로 GPU 유휴 시간 최소화

**제어 측면:**
1. **세밀한 제어**: GPU 하드웨어에 직접 접근
2. **최적화 가능성**: 드라이버 오버헤드 없이 직접 최적화
3. **리소스 바인딩**: Descriptor Heap을 통한 유연한 리소스 관리

---

### DirectX12의 단점

1. **높은 진입 장벽**: 학습 곡선이 매우 가파름
2. **개발 복잡도**: 코드량이 많고 관리할 요소가 많음
3. **디버깅 어려움**: 명시적 관리로 인한 버그 발생 가능성
4. **개발 시간**: 같은 기능 구현에 더 많은 시간 소요
5. **책임 증가**: 메모리 누수, 동기화 오류 등 모두 개발자 책임

---

### DirectX11의 장점

1. **빠른 개발**: 간단한 API로 프로토타입 빠르게 제작
2. **낮은 진입 장벽**: 상대적으로 배우기 쉬움
3. **안정성**: 드라이버가 많은 것을 자동 처리
4. **풍부한 자료**: 레퍼런스와 예제가 많음
5. **충분한 성능**: 대부분의 게임에 충분한 성능 제공

---

### DirectX11의 단점

1. **CPU 병목**: Draw Call이 많을 때 성능 저하
2. **제한된 멀티스레딩**: 멀티코어 활용도 낮음
3. **드라이버 오버헤드**: API 호출마다 검증 비용
4. **최적화 한계**: 저수준 최적화 불가능

---

### 선택 기준

**DirectX12를 선택해야 하는 경우:**
- 매우 많은 Draw Call이 필요한 경우 (오픈 월드 등)
- CPU 병목이 예상되는 대규모 프로젝트
- 멀티스레딩 렌더링이 필수적인 경우
- 최대 성능이 중요한 AAA 게임

**DirectX11을 선택해야 하는 경우:**
- 빠른 프로토타이핑이 필요한 경우
- 팀의 DX12 경험이 부족한 경우
- 개발 일정이 타이트한 경우
- 중소규모 프로젝트

---

## Q2: DXGI 라이브러리 역할과 헤더 버전 구조

**질문:**
dxgi 라이브러리의 역할은 뭐고, dxgi1_N.h 에서 N이 커질수록 이전에 header를 Include 하며 선언되는 데이터가 더 쌓던데, 무엇때문에야?

**답변:**

### DXGI (DirectX Graphics Infrastructure)의 역할

#### 1. 그래픽 API와 하드웨어 사이의 공통 계층
DXGI는 DirectX(D3D11, D3D12)와 GPU 하드웨어 사이에서 공통적인 기능을 담당하는 저수준 인프라입니다.

#### 2. 주요 책임 영역

**스왑 체인 (Swap Chain) 관리**
- 프론트 버퍼와 백 버퍼 전환
- V-Sync 제어
- 화면 출력 관리

**어댑터 (GPU) 열거 및 관리**
```cpp
IDXGIFactory* factory;
CreateDXGIFactory(__uuidof(IDXGIFactory), (void**)&factory);

// GPU 목록 가져오기
IDXGIAdapter* adapter;
factory->EnumAdapters(0, &adapter);
```

**출력 장치 (모니터) 관리**
- 디스플레이 모드 열거
- 해상도, 주사율 정보
- 멀티 모니터 지원

**리소스 공유**
- DirectX 버전 간 리소스 공유
- 윈도우 시스템과의 인터페이스

---

### DXGI 헤더 버전 구조 (dxgi1_N.h)

#### 왜 이전 헤더를 Include 하는가?

**1. 하위 호환성 (Backward Compatibility)**
```cpp
// dxgi1_2.h
#include "dxgi1_1.h"  // 1.1의 모든 인터페이스 포함

// dxgi1_3.h
#include "dxgi1_2.h"  // 1.2의 모든 인터페이스 포함 (1.1도 간접 포함)
```

이전 버전의 인터페이스를 그대로 사용할 수 있어야 하므로 계층적으로 포함합니다.

**2. COM 인터페이스 상속 구조**
```cpp
// dxgi.h
interface IDXGISwapChain : IDXGIDeviceSubObject { ... };

// dxgi1_2.h
interface IDXGISwapChain1 : IDXGISwapChain { ... };  // 기존 기능 + 새 기능

// dxgi1_3.h
interface IDXGISwapChain2 : IDXGISwapChain1 { ... };  // 점진적 확장
```

새 인터페이스가 이전 인터페이스를 상속하므로, 이전 헤더의 정의가 필요합니다.

**3. 점진적 기능 추가**

각 버전별 주요 추가 기능:

- **DXGI 1.0** (dxgi.h): 기본 스왑체인, 어댑터 열거, DirectX 10/11 지원
- **DXGI 1.1** (dxgi1_1.h): `IDXGIFactory1`, 개선된 어댑터 열거, WARP 어댑터 지원
- **DXGI 1.2** (dxgi1_2.h): `IDXGISwapChain1`, Flip Model 스왑체인, Stereo 3D 지원
- **DXGI 1.3** (dxgi1_3.h): `IDXGISwapChain2`, 프레임 레이턴시 제어, `CreateDXGIFactory2`
- **DXGI 1.4** (dxgi1_4.h): `IDXGIAdapter3`, 메모리 쿼리 개선, DirectX 12 최적화
- **DXGI 1.5** (dxgi1_5.h): `IDXGIOutput5`, HDR 지원, 색 공간 관리
- **DXGI 1.6** (dxgi1_6.h): `IDXGIAdapter4`, GPU 우선순위, Variable Refresh Rate 지원

---

#### 실제 사용 예시

```cpp
// 최신 버전 헤더만 포함
#include <dxgi1_6.h>  // 자동으로 1.5, 1.4, ... dxgi.h까지 모두 포함됨

// 하위 호환성 유지하며 사용
IDXGIFactory* factory1;        // DXGI 1.0 인터페이스
IDXGIFactory2* factory2;       // DXGI 1.2 인터페이스
IDXGIFactory6* factory6;       // DXGI 1.6 인터페이스

// 런타임에 지원 확인하며 사용
CreateDXGIFactory2(0, IID_PPV_ARGS(&factory6));
if (factory6) {
    // DXGI 1.6 기능 사용
} else {
    // 폴백: 이전 버전 사용
}
```

---

#### 개발 시 권장사항

1. **최신 헤더 사용**: 가장 높은 버전의 헤더만 include
2. **런타임 체크**: 실제 기능 사용 전 QueryInterface로 지원 확인
3. **폴백 전략**: 이전 버전 인터페이스로 대체 가능하도록 설계
4. **최소 요구사항 명시**: 게임/앱이 필요로 하는 최소 DXGI 버전 문서화

---

